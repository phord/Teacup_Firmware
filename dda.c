#include	"dda.h"

/** \file
	\brief Digital differential analyser - this is where we figure out which steppers need to move, and when they need to move
*/

#include "simulator.h"
#include	<string.h>
#include	<stdlib.h>
#include	<math.h>
#ifndef SIMULATOR
#include	<avr/interrupt.h>
#endif

#include	"dda_maths.h"
#include	"dda_lookahead.h"
#include	"timer.h"
#include	"serial.h"
#include	"sermsg.h"
#include	"gcode_parse.h"
#include	"dda_queue.h"
#include	"debug.h"
#include	"sersendf.h"
#include	"pinio.h"
#include "memory_barrier.h"
//#include "graycode.c"

#ifdef	DC_EXTRUDER
	#include	"heater.h"
#endif

/* 32-bit-specific abs fn coerces argument to 32-bit signed value first */
#define abs32(x) labs((int32_t)(x))

/*
	position tracking
*/

/// \var startpoint
/// \brief target position of last move in queue
TARGET startpoint __attribute__ ((__section__ (".bss")));

/// \var startpoint_steps
/// \brief target position of last move in queue, expressed in steps
TARGET startpoint_steps __attribute__ ((__section__ (".bss")));

/// \var current_position
/// \brief actual position of extruder head
/// \todo make current_position = real_position (from endstops) + offset from G28 and friends
TARGET current_position __attribute__ ((__section__ (".bss")));

/// \var move_state
/// \brief numbers for tracking the current state of movement
MOVE_STATE move_state __attribute__ ((__section__ (".bss")));

/// \var maximum_feedrate
/// \brief maximum allowed feedrate on each axis
const axes_uint32_t maximum_feedrate PROGMEM = {
  MAXIMUM_FEEDRATE_X,
  MAXIMUM_FEEDRATE_Y,
  MAXIMUM_FEEDRATE_Z,
  MAXIMUM_FEEDRATE_E
};

/// \var search_feedrate
/// \brief desired feedrate for homing on each axis except E
const axes_uint32_t search_feedrate PROGMEM = {
  SEARCH_FEEDRATE_X,
  SEARCH_FEEDRATE_Y,
  SEARCH_FEEDRATE_Z
};

#ifdef ACCELERATION_EXPONENTIAL
// Following scaler values auto-generated by exponential_velocity_approximation.plot
// 32 Samples: 1375000.0 ticks/division @ a=1
#define TS_RAMP 2.2
#define SEGMENT_WIDTH_SECS ( TS_RAMP / 32 )
#define SEGMENT_WIDTH_TICKS = (F_CPU * ((float) SEGMENT_WIDTH_SECS))

/* Time scaler for linear velocity ramping represented as a simple multiplier.
 * We use this as a simple way to slow down time during linear velocity tracking.
*/
#define TIMESCALER(x) (65535. * (x))
const uint16_t exponential_curve[32] PROGMEM = {
  TIMESCALER(0.00032490),    // @ t1 = 0.06875 / alpha
  TIMESCALER(0.00259623),    // @ t2 = 0.13750 / alpha
  TIMESCALER(0.00873531),    // @ t3 = 0.20625 / alpha
  TIMESCALER(0.02058211),    // @ t4 = 0.27500 / alpha
  TIMESCALER(0.03980501),    // @ t5 = 0.34375 / alpha
  TIMESCALER(0.06778281),    // @ t6 = 0.41250 / alpha
  TIMESCALER(0.10547126),    // @ t7 = 0.48125 / alpha
  TIMESCALER(0.15327135),    // @ t8 = 0.55000 / alpha
  TIMESCALER(0.21092145),    // @ t9 = 0.61875 / alpha
  TIMESCALER(0.27743737),    // @ t10 = 0.68750 / alpha
  TIMESCALER(0.35112164),    // @ t11 = 0.75625 / alpha
  TIMESCALER(0.42965602),    // @ t12 = 0.82500 / alpha
  TIMESCALER(0.51027816),    // @ t13 = 0.89375 / alpha
  TIMESCALER(0.59002784),    // @ t14 = 0.96250 / alpha
  TIMESCALER(0.66603204),    // @ t15 = 1.03125 / alpha
  TIMESCALER(0.73578708),    // @ t16 = 1.10000 / alpha
  TIMESCALER(0.79739259),    // @ t17 = 1.16875 / alpha
  TIMESCALER(0.84969899),    // @ t18 = 1.23750 / alpha
  TIMESCALER(0.89234677),    // @ t19 = 1.30625 / alpha
  TIMESCALER(0.92569740),    // @ t20 = 1.37500 / alpha
  TIMESCALER(0.95067740),    // @ t21 = 1.44375 / alpha
  TIMESCALER(0.96857275),    // @ t22 = 1.51250 / alpha
  TIMESCALER(0.98081604),    // @ t23 = 1.58125 / alpha
  TIMESCALER(0.98880317),    // @ t24 = 1.65000 / alpha
  TIMESCALER(0.99376366),    // @ t25 = 1.71875 / alpha
  TIMESCALER(0.99669177),    // @ t26 = 1.78750 / alpha
  TIMESCALER(0.99833181),    // @ t27 = 1.85625 / alpha
  TIMESCALER(0.99920194),    // @ t28 = 1.92500 / alpha
  TIMESCALER(0.99963849),    // @ t29 = 1.99375 / alpha
  TIMESCALER(0.99984525),    // @ t30 = 2.06250 / alpha
  TIMESCALER(0.99993752),    // @ t31 = 2.13125 / alpha
  TIMESCALER(0.99997625),    // @ t32 = 2.20000 / alpha
};
#endif

/*! Inititalise DDA movement structures
*/
void dda_init(void) {
	// set up default feedrate
	if (startpoint.F == 0)
		startpoint.F = next_target.target.F = SEARCH_FEEDRATE_Z;
}

/*! Distribute a new startpoint to DDA's internal structures without any movement.

	This is needed for example after homing or a G92. The new location must be in startpoint already.
*/
void dda_new_startpoint(void) {
  enum axis_e i;
  for (i=X; i < AXIS_COUNT; i++)
    startpoint_steps.axis[i] = um_to_steps(startpoint.axis[i], i);
}

/*! CREATE a dda given current_position and a target, save to passed location so we can write directly into the queue
	\param *dda pointer to a dda_queue entry to overwrite
	\param *target the target position of this move

	\ref startpoint the beginning position of this move

	This function does a /lot/ of math. It works out directions for each axis, distance travelled, the time between the first and second step

	It also pre-fills any data that the selected accleration algorithm needs, and can be pre-computed for the whole move.

	This algorithm is probably the main limiting factor to print speed in terms of firmware limitations
*/
void dda_create(DDA *dda, TARGET *target) {
  uint32_t steps;
  axes_uint32_t delta_um;
	uint32_t	distance, c_limit, c_limit_calc;
  #ifdef LOOKAHEAD
  // Number the moves to identify them; allowed to overflow.
  static uint8_t idcnt = 0;
  static DDA* prev_dda = NULL;

  if ((prev_dda && prev_dda->done) || dda->waitfor_temp)
    prev_dda = NULL;
  #endif

  if (dda->waitfor_temp)
    return;

	// initialise DDA to a known state
	dda->allflags = 0;

	if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
    sersendf_P(PSTR("\nCreate: X %lq  Y %lq  Z %lq  F %lu\n"),
               dda->endpoint.axis[X], dda->endpoint.axis[Y],
               dda->endpoint.axis[Z], dda->endpoint.F);


	// we end at the passed target
	memcpy(&(dda->endpoint), target, sizeof(TARGET));

  #ifdef LOOKAHEAD
    // Set the start and stop speeds to zero for now = full stops between
    // moves. Also fallback if lookahead calculations fail to finish in time.
    dda->F_start = 0;
    dda->start_steps = 0;
    dda->F_end = 0;
    dda->end_steps = 0;
    // Give this move an identifier.
    dda->id = idcnt++;
  #endif

  // Find distance for each axis in steps
  enum axis_e i;
  for (i = X; i < AXIS_COUNT; i++) {
    delta_um[i] = (uint32_t)abs32(target->axis[i] - startpoint.axis[i]);

    steps = um_to_steps(target->axis[i], i);
    dda->delta[i] = abs32(steps - startpoint_steps.axis[i]);
    startpoint_steps.axis[i] = steps;

    set_direction(dda, i, (target->axis[i] >= startpoint.axis[i])?1:0);
    #ifdef LOOKAHEAD
      // Also displacements in micrometers, but for the lookahead algorithms.
      dda->delta_um[i] = target->axis[i] - startpoint.axis[i];
    #endif
  }

  if (target->e_relative) {
    delta_um[E] = abs32(target->axis[E]);
    dda->delta[E] = abs32(um_to_steps(target->axis[E],E));
    dda->e_direction = (target->axis[E] >= 0)?1:0;
  }

	if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
    sersendf_P(PSTR("[%ld,%ld,%ld,%ld]"),
               target->axis[X] - startpoint.axis[X], target->axis[Y] - startpoint.axis[Y],
               target->axis[Z] - startpoint.axis[Z], target->axis[E] - startpoint.axis[E]);

	dda->total_steps = dda->delta[X];
  for (i=Y; i < AXIS_COUNT; i++) {
    if (dda->delta[i] > dda->total_steps)
      dda->total_steps = dda->delta[i];
  }

	if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
    sersendf_P(PSTR(" [ts:%lu"), dda->total_steps);

	if (dda->total_steps == 0) {
		dda->nullmove = 1;
	}
	else {
		// get steppers ready to go
		power_on();
		stepper_enable();
		x_enable();
		y_enable();
		// Z is enabled in dda_start()
		e_enable();

    distance = approx_distance_3(delta_um[X], delta_um[Y], delta_um[Z]);

		if (distance < 2)
			distance = delta_um[E];

		if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
			sersendf_P(PSTR(",ds:%lu"), distance);

    #ifndef	ACCELERATION_TEMPORAL
      // pre-calculate move speed in millimeter ticks per step minute for less math in interrupt context
      // um (distance) * F_CPU ticks/sec / step (total_steps) * 1 mm/1000um * 60 sec/min = mm.ticks per step.min
			// so in the interrupt we must simply calculate
			// mm.ticks per step.min / mm per min (F) = ticks per step

			// break this calculation up a bit and lose some precision because 300,000um * 60000 is too big for a uint32
			// calculate this with a uint64 if you need the precision, but it'll take longer so routines with lots of short moves may suffer
			// 2^32/6000 is about 715mm which should be plenty

			// changed * 10 to * (F_CPU / 100000) so we can work in cpu_ticks rather than microseconds.
			// timer.c setTimer() routine altered for same reason

			// changed distance * 6000 .. * F_CPU / 100000 to
			//         distance * 2400 .. * F_CPU / 40000 so we can move a distance of up to 1800mm without overflowing
			uint32_t move_duration = ((distance * 2400) / dda->total_steps) * (F_CPU / 40000);

    // similarly, find out how fast we can run our axes.
    // do this for each axis individually, as the combined speed of two or more
    // axes can be higher than the capabilities of a single one.
    // c_limit is the least possible move duration respecting per-axis speed limits
    c_limit = 0;
    for (i=X; i < AXIS_COUNT; i++) {
    // check each axis
//      sim_info("%i: %u    \t%u %u", i, delta_um[i], dda->total_steps , maximum_feedrate[i]);
      c_limit_calc = ((delta_um[i] * 2400L) / dda->total_steps * (F_CPU / 40000) / maximum_feedrate[i]) << 8;
      sim_info("((%u * 2400L) / %u * (%u / 40000) / %u) << 8 = %u",
          delta_um[i] , dda->total_steps , F_CPU , maximum_feedrate[i], c_limit_calc );
      if (c_limit_calc > c_limit)
        c_limit = c_limit_calc;
    }
    #endif

		#ifdef ACCELERATION_REPRAP
		// c is initial step time in IOclk ticks
		dda->c = (move_duration / startpoint.F) << 8;
		if (dda->c < c_limit)
			dda->c = c_limit;
		dda->end_c = (move_duration / target->F) << 8;
		if (dda->end_c < c_limit)
			dda->end_c = c_limit;

		if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
			sersendf_P(PSTR(",md:%lu,c:%lu"), move_duration, dda->c >> 8);

		if (dda->c != dda->end_c) {
			uint32_t stF = startpoint.F / 4;
			uint32_t enF = target->F / 4;
			// now some constant acceleration stuff, courtesy of http://www.embedded.com/columns/technicalinsights/56800129?printable=true
			uint32_t ssq = (stF * stF);
			uint32_t esq = (enF * enF);
			int32_t dsq = (int32_t) (esq - ssq) / 4;

			uint8_t msb_ssq = msbloc(ssq);
			uint8_t msb_tot = msbloc(dda->total_steps);

			// the raw equation WILL overflow at high step rates, but 64 bit math routines take waay too much space
			// at 65536 mm/min (1092mm/s), ssq/esq overflows, and dsq is also close to overflowing if esq/ssq is small
			// but if ssq-esq is small, ssq/dsq is only a few bits
			// we'll have to do it a few different ways depending on the msb locations of each
			if ((msb_tot + msb_ssq) <= 30) {
				// we have room to do all the multiplies first
				if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
					serial_writechar('A');
				dda->n = ((int32_t) (dda->total_steps * ssq) / dsq) + 1;
			}
			else if (msb_tot >= msb_ssq) {
				// total steps has more precision
				if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
					serial_writechar('B');
				dda->n = (((int32_t) dda->total_steps / dsq) * (int32_t) ssq) + 1;
			}
			else {
				// otherwise
				if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
					serial_writechar('C');
				dda->n = (((int32_t) ssq / dsq) * (int32_t) dda->total_steps) + 1;
			}

			if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
				sersendf_P(PSTR("\n{DDA:CA end_c:%lu, n:%ld, md:%lu, ssq:%lu, esq:%lu, dsq:%lu, msbssq:%u, msbtot:%u}\n"), dda->end_c >> 8, dda->n, move_duration, ssq, esq, dsq, msb_ssq, msb_tot);

			dda->accel = 1;
		}
		else
			dda->accel = 0;
		#elif defined ACCELERATION_RAMPING
    // Get max speed in us per step
		// yes, this assumes always the x axis as the critical one regarding acceleration. If we want to implement per-axis acceleration, things get tricky ...
			dda->c_min = (move_duration / target->F) << 8;
			if (dda->c_min < c_limit)
				dda->c_min = c_limit;

      /**
        Assuming: F is in mm/min, STEPS_PER_M_X is in steps/m, ACCELERATION is in mm/s²
        Given:
         - Velocity v at time t given acceleration a: v(t) = a*t
         - Displacement s at time t given acceleration a: s(t) = 1/2 * a * t²
         - Displacement until reaching target velocity v: s = 1/2 * (v² / a)
         - Final result: steps needed to reach velocity v given acceleration a:
         steps = 1/2 * (STEPS_PER_M_X * 1m/1000mm * (F * 1min/60sec)^2) / ACCELERATION
               = 1/2 * 1/1000 * (1/60)^2 * (STEPS_PER_M_X * F^2) / ACCELERATION
               = 1/2000       *  1/3600  * (STEPS_PER_M_X * F^2) / ACCELERATION
               =        1/7200000        * (STEPS_PER_M_X * F^2) / ACCELERATION
         To keep precision, break up in floating point and integer part:
           F^2 * (int)(STEPS_PER_M_X / (7200000 * ACCELERATION))
         Note: the floating point part is static so it's calculated during compilation.
         Note 2: the floating point part will be smaller than one, invert it:
                   steps = F^2 / (int)((7200000 * ACCELERATION) / STEPS_PER_M_X)
         Note 3: As mentioned, setting F to 65535 or larger will overflow the
                 calculation. Make sure this does not happen.
         Note 4: Anyone trying to run their machine at 65535 mm/min > 1m/s is nuts
       */
      if (target->F > 65534)
        target->F = 65534;

      // Note: this is inaccurate for several reasons:
      // - target->F isn't reverse-calculated from c_limit, so speed
      //   reductions due to slow axes are ignored.
      // - target->F means the speed of all axes combined, not the speed
      //   of the fast axis, which is taken into account here.
      // The good thing: taking target->F means rampup_steps is always
      // equal or larger than the number of steps required for acceleration,
      // so we can use it when also limiting max speed according to c_limit.
      dda->rampup_steps = ACCELERATE_RAMP_LEN(target->F);

      // Quick hack: we do not do Z move joins as jerk on the Z axis is undesirable;
      // as the ramp length is calculated for XY, its incorrect for Z: apply the original
      // 'fix' to simply specify a large enough ramp for any speed.
      if (delta_um[X] == 0 && delta_um[Y] == 0) {
        dda->rampup_steps = 1000000; // replace mis-calculation by a safe value
      }

      if (dda->rampup_steps > dda->total_steps / 2)
        dda->rampup_steps = dda->total_steps / 2;
      dda->rampdown_steps = dda->total_steps - dda->rampup_steps;

      #ifdef LOOKAHEAD
        dda_join_moves(prev_dda, dda);
        dda->n = dda->start_steps;
        if (dda->n == 0)
          dda->c = C0;
        else
          dda->c = ((C0 >> 8) * int_inv_sqrt(dda->n)) >> 5;
        if (dda->c < dda->c_min)
          dda->c = dda->c_min;
      #else
        dda->n = 0;
        dda->c = C0;
      #endif

		#elif defined ACCELERATION_TEMPORAL
    // TODO: calculate acceleration/deceleration for each axis

      // Max allowed speed on each axis express as Minimum tics/um
      // (60 sec/min x F_CPU ticks/sec / (FEEDRATE mm/min x 1000 um/mm )) = N ticks/um
      // bracket part of this equation in an attempt to avoid overflow: 60 * 16MHz * 5mm is >32 bits
      uint32_t move_duration, md_candidate;
      static const axes_uint32_t max_tics_per_um PROGMEM = {
        ((60 * F_CPU) / (MAXIMUM_FEEDRATE_X * 1000UL)),
        ((60 * F_CPU) / (MAXIMUM_FEEDRATE_Y * 1000UL)),
        ((60 * F_CPU) / (MAXIMUM_FEEDRATE_Z * 1000UL)),
        ((60 * F_CPU) / (MAXIMUM_FEEDRATE_E * 1000UL))
      };

      // Commanded feedrate gives ideal duration (in ticks)
      move_duration = distance * ((60 * F_CPU) / (target->F * 1000UL));

      // Apply axis limits to find attainable duration (disregarding acceleration)
      for (i=X; i < AXIS_COUNT; i++) {
        md_candidate = delta_um[i] * max_tics_per_um[i];
        if (md_candidate > move_duration)
          move_duration = md_candidate;
      }

      // Determine step interval for each axis in ticks/step
      for (i = X; i < AXIS_COUNT; i++) {
        dda->step_interval[i] = 0xFFFFFFFF;
        if (dda->delta[i])
          dda->step_interval[i] = move_duration / dda->delta[i];
      }

      #ifdef ACCELERATION_EXPONENTIAL
      // Calculate alpha_max for this movement given the feedrate
      uint32_t Vmax = c_limit ;  // TODO: Convert c_limit to proper max velocity in mm/s
      uint32_t alpha_max = ACCELERATION/(1.1754*Vmax);
      uint32_t alpha_max2 = int_sqrt((65536 * MAX_JERK/2.1524)/Vmax);
      if ( alpha_max > alpha_max2 ) alpha_max = alpha_max2 ;
      uint32_t Ts = F_CPU * TS_RAMP ;
      uint32_t Td = move_duration ;
      dda->step_scaler = exponential_curve[0];
      dda->step_scaler_next = exponential_curve[1];
      dda->scaler_index = 1;
      printf("%u %u %u %u %u\n", Vmax, alpha_max, alpha_max2, Ts, Td ) ;
      #endif

      dda->c = 0xFFFFFFFF;
      dda->axis_to_step = X; // Safety value
      for (i = X; i < AXIS_COUNT; i++) {
        if (dda->step_interval[i] < dda->c) {
          dda->axis_to_step = i;
          dda->c = dda->step_interval[i];
        }
      }

			dda->c <<= 8;
		#else
			dda->c = (move_duration / target->F) << 8;
			if (dda->c < c_limit)
				dda->c = c_limit;
		#endif
	} /* ! dda->total_steps == 0 */

	if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
		serial_writestr_P(PSTR("] }\n"));

	// next dda starts where we finish
	memcpy(&startpoint, target, sizeof(TARGET));
  #ifdef LOOKAHEAD
    prev_dda = dda;
  #endif
}

/*! Start a prepared DDA
	\param *dda pointer to entry in dda_queue to start

	This function actually begins the move described by the passed DDA entry.

	We set direction and enable outputs, and set the timer for the first step from the precalculated value.

	We also mark this DDA as running, so other parts of the firmware know that something is happening

	Called both inside and outside of interrupts.
*/
void dda_start(DDA *dda) {
	// called from interrupt context: keep it simple!

  if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
    sersendf_P(PSTR("Start: X %lq  Y %lq  Z %lq  F %lu\n"),
               dda->endpoint.axis[X], dda->endpoint.axis[Y],
               dda->endpoint.axis[Z], dda->endpoint.F);

	if ( ! dda->nullmove) {
		// get ready to go
		psu_timeout = 0;
		if (dda->delta[Z])
			z_enable();
		if (dda->endstop_check)
			endstops_on();

		// set direction outputs
		x_direction(dda->x_direction);
		y_direction(dda->y_direction);
		z_direction(dda->z_direction);
		e_direction(dda->e_direction);

		#ifdef	DC_EXTRUDER
		if (dda->delta[E])
			heater_set(DC_EXTRUDER, DC_EXTRUDER_PWM);
		#endif

		// initialise state variable
		move_state.counter[X] = move_state.counter[Y] = move_state.counter[Z] = \
			move_state.counter[E] = -(dda->total_steps >> 1);
		memcpy(&move_state.steps[X], &dda->delta[X], sizeof(uint32_t) * 4);
    move_state.endstop_stop = 0;
		#ifdef ACCELERATION_RAMPING
			move_state.step_no = 0;
		#endif
		#ifdef ACCELERATION_TEMPORAL
		move_state.time[X] = move_state.time[Y] = \
			move_state.time[Z] = move_state.time[E] = 0UL;
		#endif

		// ensure this dda starts
		dda->live = 1;

		// set timeout for first step
    setTimer(dda->c >> 8);
	}
	// else just a speed change, keep dda->live = 0

	current_position.F = dda->endpoint.F;
}

/*! STEP
	\param *dda the current move

	This is called from our timer interrupt every time a step needs to occur. Keep it as simple as possible!
	We first work out which axes need to step, and generate step pulses for them
	Then we re-enable global interrupts so serial data reception and other important things can occur while we do some math.
	Next, we work out how long until our next step using the selected acceleration algorithm and set the timer.
	Then we decide if this was the last step for this move, and if so mark this dda as dead so next timer interrupt we can start a new one.
	Finally we de-assert any asserted step pins.
*/
void dda_step(DDA *dda) {
  enum axis_e i;


#if ! defined ACCELERATION_TEMPORAL
  for (i = X; i < AXIS_COUNT; i++) {
    if (move_state.steps[i]) {
      move_state.counter[i] -= dda->delta[i];
      if (move_state.counter[i] < 0) {
        do_step(i);
        move_state.steps[i]--;
        move_state.counter[i] += dda->total_steps;
      }
    }
  }
#else	// ACCELERATION_TEMPORAL
  i = dda->axis_to_step;
  do_step(i);
  move_state.steps[i]--;
  move_state.time[i] += dda->step_interval[i];
  move_state.last_time = move_state.time[i];
#endif

	#if STEP_INTERRUPT_INTERRUPTIBLE && ! defined ACCELERATION_RAMPING
		// Since we have sent steps to all the motors that will be stepping
		// and the rest of this function isn't so time critical, this interrupt
		// can now be interruptible by other interrupts.
		// The step interrupt is disabled before entering dda_step() to ensure
		// that we don't step again while computing the below.
		sei();
	#endif

	#ifdef ACCELERATION_REPRAP
		// linear acceleration magic, courtesy of http://www.embedded.com/columns/technicalinsights/56800129?printable=true
		if (dda->accel) {
			if ((dda->c > dda->end_c) && (dda->n > 0)) {
				uint32_t new_c = dda->c - (dda->c * 2) / dda->n;
				if (new_c <= dda->c && new_c > dda->end_c) {
					dda->c = new_c;
					dda->n += 4;
				}
				else
					dda->c = dda->end_c;
			}
			else if ((dda->c < dda->end_c) && (dda->n < 0)) {
				uint32_t new_c = dda->c + ((dda->c * 2) / -dda->n);
				if (new_c >= dda->c && new_c < dda->end_c) {
					dda->c = new_c;
					dda->n += 4;
				}
				else
					dda->c = dda->end_c;
			}
			else if (dda->c != dda->end_c) {
				dda->c = dda->end_c;
			}
			// else we are already at target speed
		}
	#endif

	#ifdef ACCELERATION_RAMPING
		move_state.step_no++;
	#endif

  #ifdef ACCELERATION_TEMPORAL
    /** How is this ACCELERATION TEMPORAL expected to work?

      All axes work independently of each other, as if they were on four
      different, synchronized timers. As we have not enough suitable timers,
      we have to share one for all axes.

      To do this, each axis maintains the time of its last step in
      move_state.time[]. This time is updated as the step is done, see early
      in dda_step(). To find out which axis is the next one to step, the time
      of each axis' next step is compared to the time of the step just done.
      Zero means this actually is the axis just stepped, the smallest value > 0
      wins.

      One problem undoubtedly arising is, steps should sometimes be done at
      {almost,exactly} the same time. We trust the timer to deal properly with
      very short or even zero periods. If a step can't be done in time, the timer
      shall do the step as soon as possible and compensate for the delay later. In
      turn we promise here to send a maximum of four such short-delays consecutively
      and to give sufficient time on average.
   */
		uint32_t c_candidate;

		dda->c = 0xFFFFFFFF;
    for (i = X; i < AXIS_COUNT; i++) {
      if (move_state.steps[i]) {
        c_candidate = move_state.time[i] + dda->step_interval[i] - move_state.last_time;
        if (c_candidate < dda->c) {
          dda->axis_to_step = i;
          dda->c = c_candidate;
        }
      }
    }
		dda->c <<= 8;
	#endif

  // If there are no steps left or an endstop stop happened, we have finished.
  if ((move_state.steps[X] == 0 && move_state.steps[Y] == 0 &&
       move_state.steps[Z] == 0 && move_state.steps[E] == 0)
    #ifdef ACCELERATION_RAMPING
      || (move_state.endstop_stop && dda->n == 0)
    #endif
      ) {
		dda->live = 0;
    dda->done = 1;
    #ifdef LOOKAHEAD
    // If look-ahead was using this move, it could have missed our activation:
    // make sure the ids do not match.
    dda->id--;
    #endif
		#ifdef	DC_EXTRUDER
			heater_set(DC_EXTRUDER, 0);
		#endif
		// z stepper is only enabled while moving
		z_disable();
	}
  else {
		psu_timeout = 0;
    // After having finished, dda_start() will set the timer.
    setTimer(dda->c >> 8);
  }

	// turn off step outputs, hopefully they've been on long enough by now to register with the drivers
	// if not, too bad. or insert a (very!) small delay here, or fire up a spare timer or something.
	// we also hope that we don't step before the drivers register the low- limit maximum speed if you think this is a problem.
	unstep();
}

/*! Do regular movement maintenance.

  This should be called pretty often, like once every 1 or 2 milliseconds.

  Currently, this is checking the endstops and doing acceleration maths. These
  don't need to be checked/recalculated on every single step, so this code
  can be moved out of the highly time critical dda_step(). At high precision
  (slow) searches of the endstop, this function is called more often than
  dda_step() anyways.

  In the future, arc movement calculations might go here, too. Updating
  movement direction 500 times a second is easily enough for smooth and
  accurate curves!
*/
void dda_clock() {
  static volatile uint8_t busy = 0;
  DDA *dda;
  static DDA *last_dda = NULL;
  uint8_t endstop_trigger = 0;
#ifdef ACCELERATION_RAMPING
  uint32_t move_step_no, move_c;
  uint8_t recalc_speed;
#endif

  dda = queue_current_movement();
  if (dda != last_dda) {
    move_state.debounce_count_xmin = move_state.debounce_count_ymin =
    move_state.debounce_count_zmin = move_state.debounce_count_xmax =
    move_state.debounce_count_ymax = move_state.debounce_count_zmax = 0;
    last_dda = dda;
  }

  if (dda == NULL)
    return;

  // Lengthy calculations ahead!
  // Make sure we didn't re-enter, then allow nested interrupts.
  if (busy)
    return;
  busy = 1;
  sei();

  // Caution: we mangle step counters here without locking interrupts. This
  //          means, we trust dda isn't changed behind our back, which could
  //          in principle (but rarely) happen if endstops are checked not as
  //          endstop search, but as part of normal operations.
  if (dda->endstop_check && ! move_state.endstop_stop) {
    #if defined X_MIN_PIN || defined X_MAX_PIN
    if (dda->endstop_check & 0x1) {
      #if defined X_MIN_PIN
      if (x_min() == dda->endstop_stop_cond)
        move_state.debounce_count_xmin++;
      else
        move_state.debounce_count_xmin = 0;
      #endif
      #if defined X_MAX_PIN
      if (x_max() == dda->endstop_stop_cond)
        move_state.debounce_count_xmax++;
      else
        move_state.debounce_count_xmax = 0;
      #endif
      endstop_trigger = move_state.debounce_count_xmin >= ENDSTOP_STEPS ||
                        move_state.debounce_count_xmax >= ENDSTOP_STEPS;
    }
    #endif

    #if defined Y_MIN_PIN || defined Y_MAX_PIN
    if (dda->endstop_check & 0x2) {
      #if defined Y_MIN_PIN
      if (y_min() == dda->endstop_stop_cond)
        move_state.debounce_count_ymin++;
      else
        move_state.debounce_count_ymin = 0;
      #endif
      #if defined Y_MAX_PIN
      if (y_max() == dda->endstop_stop_cond)
        move_state.debounce_count_ymax++;
      else
        move_state.debounce_count_ymax = 0;
      #endif
      endstop_trigger = move_state.debounce_count_ymin >= ENDSTOP_STEPS ||
                        move_state.debounce_count_ymax >= ENDSTOP_STEPS;
    }
    #endif

    #if defined Z_MIN_PIN || defined Z_MAX_PIN
    if (dda->endstop_check & 0x4) {
      #if defined Z_MIN_PIN
      if (z_min() == dda->endstop_stop_cond)
        move_state.debounce_count_zmin++;
      else
        move_state.debounce_count_zmin = 0;
      #endif
      #if defined Z_MAX_PIN
      if (z_max() == dda->endstop_stop_cond)
        move_state.debounce_count_zmax++;
      else
        move_state.debounce_count_zmax = 0;
      #endif
      endstop_trigger = move_state.debounce_count_zmin >= ENDSTOP_STEPS ||
                        move_state.debounce_count_zmax >= ENDSTOP_STEPS;
    }
    #endif

    // If an endstop is definitely triggered, stop the movement.
    if (endstop_trigger) {
      #ifdef ACCELERATION_RAMPING
        // For always smooth operations, don't halt apruptly,
        // but start deceleration here.
        ATOMIC_START
          move_state.endstop_stop = 1;
          if (move_state.step_no < dda->rampup_steps)  // still accelerating
            dda->total_steps = move_state.step_no * 2;
          else
            // A "-=" would overflow earlier.
            dda->total_steps = dda->total_steps - dda->rampdown_steps +
                               move_state.step_no;
          dda->rampdown_steps = move_state.step_no;
        ATOMIC_END
        // Not atomic, because not used in dda_step().
        dda->rampup_steps = 0; // in case we're still accelerating
      #else
        dda->live = 0;
      #endif

      endstops_off();
    }
  } /* ! move_state.endstop_stop */

  #ifdef ACCELERATION_RAMPING
    // For maths about stepper speed profiles, see
    // http://www.embedded.com/columns/technicalinsights/56800129?printable=true
    // and http://www.atmel.com/images/doc8017.pdf (Atmel app note AVR446)
    ATOMIC_START
      move_step_no = move_state.step_no;
      // All other variables are read-only or unused in dda_step(),
      // so no need for atomic operations.
    ATOMIC_END

    recalc_speed = 0;
    if (move_step_no < dda->rampup_steps) {
      #ifdef LOOKAHEAD
        dda->n = dda->start_steps + move_step_no;
      #else
        dda->n = move_step_no;
      #endif
      recalc_speed = 1;
    }
    else if (move_step_no >= dda->rampdown_steps) {
      #ifdef LOOKAHEAD
        dda->n = dda->total_steps - move_step_no + dda->end_steps;
      #else
        dda->n = dda->total_steps - move_step_no;
      #endif
      recalc_speed = 1;
    }
    if (recalc_speed) {
      if (dda->n == 0)
        move_c = C0;
      else
        // Explicit formula: sqrt(n + 1) - sqrt(n),
        // approximation here: 1 / (2 * sqrt(n)).
        move_c = ((C0 >> 8) * int_inv_sqrt(dda->n)) >> 5;

      if (move_c < dda->c_min) {
        // We hit max speed not always exactly.
        move_c = dda->c_min;

        // This is a hack which deals with movements with an unknown number of
        // acceleration steps. dda_create() sets a very high number, then,
        // but we don't want to re-calculate all the time.
        // This hack doesn't work with (and isn't neccessary for) movements
        // accelerated by look-ahead.
        #ifdef LOOKAHEAD
          if (dda->crossF == 0) {  // For example, endstop searches.
            dda->rampup_steps = move_step_no;
            dda->rampdown_steps = dda->total_steps - dda->rampup_steps;
          }
        #else  // Without LOOKAHEAD, there's no dda->crossF.
          dda->rampup_steps = move_step_no;
          dda->rampdown_steps = dda->total_steps - dda->rampup_steps;
        #endif
      }

      // Write results.
      ATOMIC_START
        dda->c = move_c;
      ATOMIC_END
    }
  #endif

  cli(); // Compensate sei() above.
  busy = 0;
}

/// update global current_position struct
void update_current_position() {
	DDA *dda = &movebuffer[mb_tail];
  enum axis_e i;

  /* Use smaller values to adjust to avoid overflow in later calculations */
  // (STEPS_PER_M_X / 1000) is a bit inaccurate for low STEPS_PER_M numbers
  static const axes_uint32_t steps_per_cm PROGMEM = {
    ((STEPS_PER_M_X + 500) / 1000),
    ((STEPS_PER_M_Y + 500) / 1000),
    ((STEPS_PER_M_Z + 500) / 1000),
    ((STEPS_PER_M_E + 500) / 1000)
  };

  if (queue_empty()) {
    for (i=X; i < AXIS_COUNT; i++) {
      current_position.axis[i] = startpoint.axis[i];
    }
  }
  else if (dda->live) {
    for (i=X; i < AXIS_COUNT; i++) {
      if (get_direction(dda, i))
        current_position.axis[i] = dda->endpoint.axis[i] -
                                   move_state.steps[i] * 1000 / steps_per_cm[i];
      else
        current_position.axis[i] = dda->endpoint.axis[i] +
                                   move_state.steps[i] * 1000 / steps_per_cm[i];
    }
    if (dda->endpoint.e_relative)
      current_position.axis[E] = move_state.steps[E] * 1000 / steps_per_cm[E];
    // current_position.F is updated in dda_start()
  }
}

/********************************************************************
 * Axis decoders
 *
 * Specialized functions that turn an axis_e into a specific PIN or bit
 * action.
 ********************************************************************/

// step the 'n' axis
void do_step(enum axis_e n) {
  if (n == X)
    x_step();
  else if (n == Y)
    y_step();
  else if (n == Z)
    z_step();
  else if (n == E)
    e_step();
}

int get_direction(DDA *dda, enum axis_e n) {
  if (n == X)
    return dda->x_direction;
  if (n == Y)
    return dda->y_direction;
  if (n == Z)
    return dda->z_direction;
  if (n == E)
    return dda->e_direction;
  return 0;
}

void set_direction(DDA *dda, enum axis_e n, int dir) {
  if (n == X)
    dda->x_direction = dir;
  else if (n == Y)
    dda->y_direction = dir;
  else if (n == Z)
    dda->z_direction = dir;
  else if (n == E)
    dda->e_direction = dir;
}
